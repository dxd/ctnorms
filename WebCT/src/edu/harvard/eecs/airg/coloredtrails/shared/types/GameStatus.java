/*
	Colored Trails

	Copyright (C) 2006-2008, President and Fellows of Harvard College.
	All Rights Reserved.

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/

package edu.harvard.eecs.airg.coloredtrails.shared.types;

import edu.harvard.eecs.airg.coloredtrails.shared.Scoring;

import java.io.Serializable;
import java.util.Observer;
import java.util.Observable;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashSet;
import java.util.Collection;
import java.util.ArrayList;

/**
<b>Description</b>
Represents the state of a game instance.

<p>

<b>Issues</b>

<p>

<b>Observers</b>
The subclass ServerGameStatus is observed by GamesStatusSender; the
registration is done in server.ServerData.addNewGame().
[ADD NOTES on observers of the subclass ClientGameStatus.]

<p>

<b>Notifications</b>

<table width="100%" cellpadding=10 bgcolor=silver>
    <tr><td>Method</td><td>Message Sent</td></tr>
    <tr><td>setBoard(...)</td><td>BOARD_CHANGED</td></tr>
	<tr><td>setPlayers(...)</td><td>PLAYERS_CHANGED</td></tr>
	<tr><td>setPhases(...)</td><td>PHASES_CHANGED</td></tr>
	<tr><td>setLog(...)</td><td>LOG_CHANGED</td></tr>
	<tr><td>setStarted()</td><td>GAME_START</td></tr>
	<tr><td>setEnded()</td><td>GAME_END</td></tr>
</table>

Observers are notified when GameStatus receives the following notifications in method 'update()':

<table width="100%" cellpadding=10 bgcolor=silver>
    <tr><td>Message In</td><td>Message Out</td></tr>
    <tr><td>BOARD_CHANGED</td><td>BOARD_CHANGED</td></tr>
	<tr><td>PLAYER_CHANGED</td><td>PLAYER_CHANGED</td></tr>
	<tr><td>PHASE_ADVANCED</td><td>PHASE_ADVANCED</td></tr>
	<tr><td>LOG_CHANGED</td><td>LOG_CHANGED</td></tr>
</table>

The subclass ClientGameStatus sends NEXT_PHASE notification when its
notifyObserversPhaseAdvanced() method is called.

<p>

<b>Classes Observed</b>
The GameStatus instance observes instances of:  PlayerStatus, HistoryLog,
Phases; subclass ServerGameStatus registers as an observer of Board.

<table width="100%" cellpadding=10 bgcolor=silver>
    <tr><td>Message Checked</td><td>Class of Message Origin</td></tr>
    <tr><td>BOARD_CHANGED</td><td>types.Board</td></tr>
	<tr><td>PLAYER_CHANGED</td><td>types.PlayerStatus</td></tr>
	<tr><td>PHASE_ADVANCED</td><td>types.Phases</td></tr>
	<tr><td>LOG_CHANGED</td><td>types.HistoryLog</td></tr>
</table>

<p>

<b>Future Development</b>
The GameStatus object updates its player list as a whole; that is,
the current list is replaced by a new list.
<p>
[STATE where this list is first made -- in configuration class?]
<p>
In contrast, we can imagine methods to add and remove individual players;
such methods are merely a convenience to avoid having to rebuild a player
list, though these methods might be more appropriately placed somewhere
other than this class.  The notification "PLAYERS_CHANGED" would still
be appropriate.

<p>

<b>Original Summary</b>
 * A game type describing the overall status of a single game as a whole.
 * Contains many of the other game types.
 *
 * @author Paul Heymann (ct3@heymann.be)
   @author Sevan G. Ficici (modifications for partial visibility)
 */
public class GameStatus extends CTStateContainer
                        implements Observer, Serializable, Cloneable
{

	/** [name of configuration class associated with game?] */
//    protected String configName;
	/** set of player states */
//    protected Set<PlayerStatus> players = new HashSet<PlayerStatus>();
	/** the game board */
//    protected Board board = new Board(1, 1);
	/** the ID of this game instance; gameId is generated by server */
//    protected int gameId = -1;
	/** the phases of this game */
//    protected Phases phases;// = new Phases();
	/** the history log for this game */
//    protected HistoryLog log = new HistoryLog();

//    protected Scoring score = null;

    /** the Game Palette for this game (Monira 2-8-2006 */
//    protected GamePalette gamePalette = new GamePalette();
	
//    protected boolean isStarted = false;
//    protected boolean isInitialized = false;
	
	/** features that are to be excluded by GameStatus copy constructor */
	private static ArrayList<String> excludefeatures;
	
	static
	{
		// make list of features that are to be excluded by GameStatus copy
		// constructor
		excludefeatures = new ArrayList<String>();
		excludefeatures.add("gcdr");
	}
	
	
	/************************************************************/
	// CODE TAKEN FROM ObservableInitializableObject -- needed?
//    protected boolean initialized = false;

	// NOTE: should change name of method -- same as another method below that does very different work
    protected void setInitialized(boolean b)
    {
    	set("gsinitialized", new Boolean(b));
    }

    protected void throwIfNotInitialized()
    {
        if (!(Boolean)get("gsinitialized"))
            throw new RuntimeException("Class is not initialized." +
                    "Did you use the default constructor and then fail " +
                    "to properly add data?");
    }
	/************************************************************/


    /************************
		CONSTRUCTORS
	************************/

    public GameStatus()
    {
    	this("GameStatus");
/*    	
    	super("GameStatus", "Server");
    	// set of player states
    	set("players", new HashSet<PlayerStatus>());
    	// initial game board
    	set("board", new Board(1, 1));
    	// the ID of this game instance; gameId is generated by server
    	set("gameId", new Integer(-1));
    	// the history log for this game
    	set("log", new HistoryLog());
    	// the color palette for this game
    	set("gamePalette", new GamePalette());
    	// flag indicating whether game has started
    	set("isStarted", Boolean.FALSE);
    	// flag indicating whether game state has been initialized
    	set("isInitialized", Boolean.FALSE);
    	// flag previously used in ObservableInitializableObject
    	set("gsinitialized", Boolean.FALSE);
    	
        getHistoryLog().addObserver(this);
*/
    }

    public GameStatus(String gamestatustype)
    {
    	super(gamestatustype, "Server");
    	// set of player states
    	set("players", new HashSet<PlayerStatus>());
    	// initial game board
    	set("board", new Board(1, 1));
    	// the ID of this game instance; gameId is generated by server
    	set("gameId", new Integer(-1));
    	// the history log for this game
    	set("log", new HistoryLog());
    	// the color palette for this game
    	set("gamePalette", new GamePalette());
    	// flag indicating whether game has started
    	set("isStarted", Boolean.FALSE);
    	// flag indicating whether game state has been initialized
    	set("isInitialized", Boolean.FALSE);
        //flag indicating whether game has ended
        set("isEnded", Boolean.FALSE);
    	// flag previously used in ObservableInitializableObject
    	set("gsinitialized", Boolean.FALSE);
    	//flag indicating whether game has a chips revelation phase. used only for WebCT
        set("isChipRevelationGame", Boolean.FALSE);
    	//flag indicating whether the path finder will be visible or not. used only for WebCT
        set("showPathFinder", Boolean.FALSE);
    	
        getHistoryLog().addObserver(this);
    }
	
    // 2-9-2006 Monira : Adding game pallete
    public GameStatus(String gamestatustype,
    				  String configName, Collection players, 
                      int gameId, GamePalette gamePalette)
    {
        this(gamestatustype);
        set("configName", configName);
        set("players", new HashSet<PlayerStatus>(players));
        set("gameId", new Integer(gameId));
        set("gamePalette", new GamePalette(gamePalette));
        setInitialized(true);
    }
    
    
    // NOTE:  may want to replace with super(g); constructor call
    public GameStatus(GameStatus g)
    {
    	super(g, excludefeatures);
 //   	super(g);
 //   	remove("gcdr");  // strip out subclass features
    }
    
/*
    public GameStatus(GameStatus g, boolean shedsubclass)
    {
		this("GameStatus", g.getConfigName(), g.getPlayers(), 
		     g.getGameId(), g.getGamePalette());
		
    }
*/
    
    public Object clone()
    {
    	return new GameStatus(this);
    }
	
	public String getConfigName()
	{
		return (String)get("configName");
	}
	
    /**
     * Returns the current board configuration of the game.
     */
    public Board getBoard()
    {
    	return (Board)get("board");
    }

    /**
     * Set the current board configuration of the game.
     *
     * @param board The board status of the game.
     */
    public void setBoard(Board board)
    {
    	set("board", board);
        //board.addObserver(this);  // SHOULD UNCOMMENT???
        setChanged();
        notifyObservers("BOARD_CHANGED");
    }

    /**
     * Returns the current game palette configuration of the game.
     */
    public GamePalette getGamePalette()
    {
    	return (GamePalette)get("gamePalette");
    }


    /**
     * Set the current game palette of the game.
	 *
	 * @param gamePaletteParam The game palette of the game.
     */
    public void setGamePalette(GamePalette gamePaletteParam)
    {
    	set("gamePalette", gamePaletteParam);
		setChanged();
		notifyObservers("GAME_PALETTE_CHANGE");
    }

    /**
     * Set the game to a started state.
     */
    public void setStarted()
    {
    	set("isStarted", Boolean.TRUE);
        setChanged();
        notifyObservers("GAME_START");
    }

    /**
     * Notify observers that game has been initialized by game configuration class run() method
     * @author sevan
     */
    public void setInitialized()
    {
    	set("isInitialized", Boolean.TRUE);
    	setChanged();
    	notifyObservers("GAME_INITIALIZED");
    }

    /**
     * Set the game to an ended state.
     */
    public void setEnded()
    {
    	set("isStarted", Boolean.FALSE);
    	set("isInitialized", Boolean.FALSE);
        set("isEnded", Boolean.TRUE);
        setChanged();
        notifyObservers("GAME_END");
    }

    /**
     * Get the log of actions which have occurred in the game thus far.
     *
     * @return The log of actions which have occurred in the game thus far.
     */
    public HistoryLog getHistoryLog()
    {
    	return (HistoryLog)get("log");
    }

    /**
     * Set the log to a new history log.
     *
     * @param log The new history log.
     */
    public void setHistoryLog(HistoryLog log)
    {
    	if( getHistoryLog() != null )
    		getHistoryLog().deleteObservers();
    	
    	set("log", log);
		getHistoryLog().addObserver(this);
        setChanged();
        notifyObservers("LOG_CHANGED");
    }

    /**
     * Get the current set of phases associated with the game.
     *
     * @return The phases associated with the game.
     */
    public Phases getPhases()
    {
    	return (Phases)get("phases");
    }

    /**
     * Set the current set of phases associated with the game.
     *
     * @param phases The new phases associated with the game.
     */
    public void setPhases(Phases phases)
    {
	    System.out.println( "setPhases in GameStatus");
	    
	    if( getPhases() != null )
	        getPhases().deleteObserver( this );
	        
	    set("phases", phases);
	    //phases.resetTimer();  // REMOVE???
        getPhases().addObserver(this);
        setChanged();
        notifyObservers("PHASES_CHANGED");
    }

    /**
     * Get a list of players participating in the game.
     *
     * @return A list of players participating in the game.
     */
    public Set<PlayerStatus> getPlayers()
    {
    	return (Set<PlayerStatus>)get("players");
    }

    /**
     * Get a player given that players per game id.
     *
     * @param id The per game id of the player.
     * @return The player object associated with the per game id in this
     *         game.
     */
    public PlayerStatus getPlayerByPerGameId(int id)
    {
        for (PlayerStatus p : getPlayers())
            if (p.getPerGameId() == id)
                return p;
		
        return null;
    }
	
    /**
     * Set the participating players in the game.
     *
     * @param al A list of players designated to participate in the game.
     */
    public void setPlayers(Set<PlayerStatus> al)
    {
    	Set<PlayerStatus> oldPlayers = getPlayers();
        set("players", al);
		
        for (PlayerStatus p : getPlayers())
            p.addObserver(this);
        
        doAllInitializedCheck();
        setChanged();
        notifyObservers("PLAYER_CHANGED");
        
    	if( oldPlayers != null ) {
	        for (PlayerStatus p : oldPlayers) {
	            p.deleteObservers();
	        }
	        //oldPlayers.clear();
    	}
    }

    public Scoring getScoring()
    {
    	return (Scoring)get("score");
    }

    public void setScoring( Scoring scoring )
    {
    	set("score", scoring);
        setChanged();
        notifyObservers("SCORING_CHANGED");
    }

    /**
     * Determine whether the game is started.
     *
     * @return Whether the game is started.
     */
    public boolean isStarted()
    {
    	return (Boolean)get("isStarted");
    }
    
    public boolean isEnded()
    {
        return( (Boolean)get("isEnded") );
    }
    
    public boolean isChipRevelationGame()
    {
        return( (Boolean)get("isChipRevelationGame") );        
    }
    
    public boolean showPathFinder()
    {
        return( (Boolean)get("showPathFinder") );
    }
    
    /**
     * set to true if game has chips revelation phase.
     * <b>use only for WebCT clients!!!</b>
     * @param flag true/false
     */
    public void setIsRevelationGame(boolean flag)
    {
        set("isChipRevelationGame", flag);
        setChanged();        
        notifyObservers("PLAYER_CHANGED");
    }
    
    /**
     * set to true for path finder to be visible on the client
     * <b>use only for WebCT clients!!!</b>
     * @param flag true/false
     */
    public void setShowPathFinder(boolean flag)
    {
        set("showPathFinder", flag);
        setChanged();
        notifyObservers("PLAYER_CHANGED");
    }

    /**
     * Returns true if game has been initialized
     */
    public boolean isInitialized()
    {
    	return (Boolean)get("isInitialized");
    }
	
    /**
     * Get the game id of this game.
     *
     * @return The game id of this game.
     */
    public int getGameId()
    {
        throwIfNotInitialized();
        return (Integer)get("gameId");
    }

    /**
     * Get the set of the players with the given team id
     * @param teamId Integer representing a team
     * @return Set of PlayerStatus with the team id "teamId"
     * @author ilke
     */
    public Set<PlayerStatus> getTeam(int teamId)
    {
    	LinkedHashSet<PlayerStatus> team = new LinkedHashSet<PlayerStatus>();
    	if(teamId != -1)
			for(PlayerStatus ps : getPlayers())
				if(ps.getTeamId() == teamId)
					team.add(ps);
		
    	return team;
    }
    
    
    
    
    
    public void update(Observable observed, Object notification) {
        String noteString = (String) notification;

        if (noteString.equals("BOARD_CHANGED")) {
            setChanged();
            notifyObservers("BOARD_CHANGED");
        } else if (noteString.equals("PLAYER_CHANGED")) {
            setChanged();
            notifyObservers("PLAYER_CHANGED");
        } else if (noteString.equals("PHASE_ADVANCED")) {
            setChanged();
            notifyObservers("PHASE_ADVANCED");
        } else if (noteString.equals("LOG_CHANGED")) {
            setChanged();
            notifyObservers("LOG_CHANGED");
        } else if (noteString.equals("GAME_PALETTE_CHANGE")) {
            setChanged();
            notifyObservers("GAME_PALETTE_CHANGE");
        } else if (noteString.equals("SCORING_CHANGED")) {
            setChanged();
            notifyObservers("SCORING_CHANGED");
        } else {
            System.out.println( "Warning: Change in GameStatus update not caught. " + noteString );
        }
    }
	
    protected void doAllInitializedCheck()
    {
        //this is garbage - MMD
        
//    	// NOTE: can't use getGameId() because haven't yet setInitialized(true)
//        if (isInitialized() || ( getConfigName().length() > 0 && (Integer)get("gameId") != -1))
////        getGameId() != -1)
            setInitialized(true);
    }
	
    public String toString()
    {
        String playersString = "Game Players: {";
        for (PlayerStatus in : getPlayers()) {
            playersString = playersString + in.getPin() + "," + " pergameid: " + in.getPerGameId() + " ,";
        }
        playersString = playersString + "}\n";
        return "Configuration Name: {" + getConfigName() + "}\n" +
                "Game ID: {" + getGameId() + "}\n" + playersString;
    }
    
    /**
     * Updates GameStatus object with message received from server
     * @param txtmsg
     */
    public void setArbitraryMessage(String txtmsg){
        if(txtmsg == null)
            return;
        setChanged();
        notifyObservers(txtmsg);
    }

}